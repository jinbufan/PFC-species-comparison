#################################################################################################
##### Single-Cell Hi-C Based Validation of Cell Type-Biased CRE and Human-Biased Gene Loops #####
#################################################################################################

suppressPackageStartupMessages({
library(ArchR)
library(viridis)
library(ggplot2)
library(ggrepel)
library(reshape2)
library(plyr)
library(RColorBrewer)
library(data.table)
library(Matrix)
})
setwd('/data/work/jinbufan/review/00_HIC_cycle')


############################################
############ Data preparation ##############
############################################
## Inpute CREs\biasGene\p2g\peak\archr data
hes <- read.csv("/data/work/Brain/project/ATAC/humanPFC/00.peak_file/HES_preference-log2.csv",check.names=F,row.names=1)
hss <- read.csv("/data/work/Brain/project/ATAC/humanPFC/00.peak_file/HSS_preference-log2.csv",check.names=F,row.names=1)
mc <- read.csv("/data/work/Brain/project/ATAC/humanPFC/00.peak_file/MC_preference_log2.csv",check.names=F,row.names=1)

peak_df = rbind(hes,hss,mc)
table(peak_df$max_celltype)

biasGene <- read.csv("/data/work/jinbufan/05.Table/human-biased-gene.csv",check.names=F)
p2g <- readRDS("/data/work/Brain/project/ATAC/humanPFC/00.peak_file/filt_p2gGR.rds")

peak <- readRDS("/data/work/Brain/project/ATAC/humanPFC/00.peak_file/human_peakSet.rds") 
proj <- readRDS("/data/work/Brain/project/ATAC/humanPFC/output/human.rds")  
promoters_gr <- promoters(getGenes(proj)) 

## Path of single-cell HIC data
matched_df = read.table("/data/work/jinbufan/review/00_HIC_cycle/EX_cells_data_path.txt",header=T)
table(matched_df$MajorType)
dim(matched_df)
head(matched_df)

## Set the required cell types 
hic_ct = c("L2/3-IT","L4-IT","L5-ET","L5-IT","L5/6-NP","L6-CT","L6-IT","L6-IT-Car3","L6b")  ## Taking EX in HIC data as an example
atac_ct = c("EX_L23_IT","EX_L4_IT","EX_L5_ET","EX_L5_IT","EX_L5_NP","EX_L6_CT","EX_L6_IT","EX_L6_IT_Car3","EX_L6b")  ## subset EX in data
length(hic_ct)
length(atac_ct)



############################################
######### Validate each cell type ########## 
############################################
for (i in 1:length(atac_ct)){
    ## Create a folder to store all outputs of this cell type
    dir.create(atac_ct[i],recursive =T)
    setwd(atac_ct[i])
    
    l23it = peak_df[which(peak_df$max_celltype == atac_ct[i]),]  ## atac_ct celltype name
    peaks = rownames(l23it)
    print(paste0("The cell types starting now is：" , atac_ct[i]))
    print(paste0("The unique peak number for this cell type is：",length(unique(peaks))))
    print(paste0("The current working path is：" , getwd()))
    
    #### Select cell type specific peaks
    p2g_23 <- p2g[which(p2g$peakName %in% peaks & p2g$symbol %in% biasGene$gene),]
    print(paste0( "The actual number of loops for this cell type is：", length(p2g_23)))
    
    #The criteria for fake pairs: 
    # 1. CRE is the real CRE, but there cannot be a link 
    # 2. CRE must be on the same chromosome as the true pair's CRE 
    # 3. The distance between fake pairs must be close to that of the true pair
    ####### Obtain fake pairs for comparison purposes
    p2g_filt = p2g_23
    
    # For each p2g row, find the promoter for the corresponding gene
    idx_prom_p2g <- match(p2g_filt$symbol, promoters_gr$symbol)

    # remove NA value
    keep <- !is.na(idx_prom_p2g)
    p2g_use <- p2g_filt[keep]
    idx_prom_p2g <- idx_prom_p2g[keep]
    prom_p2g <- promoters_gr[idx_prom_p2g]
    
    # Same length GRanges
    p2g_use$dist_prom <- distance(p2g_use, prom_p2g, ignore.strand = TRUE)
    ##----------------------------------
    ## 3. Find the nearest promoter (candidate negative control) for all peaks
    ##----------------------------------

    hits_all <- distanceToNearest(peak, promoters_gr, ignore.strand = TRUE)

    peak_idx_all <- queryHits(hits_all)
    prom_idx_all <- subjectHits(hits_all)
    dist_all     <- mcols(hits_all)$distance

    cand_bg <- DataFrame(
      peak_idx  = peak_idx_all,
      prom_idx  = prom_idx_all,
      peakName  = peak$peakName[peak_idx_all],      
      gene      = promoters_gr$symbol[prom_idx_all],
      dist      = dist_all)
    
    ##----------------------------------
    ## 4. Remove real p2g pairs from the candidate pool
    ##----------------------------------

    # True positive sample ID
    pos_id <- paste0(p2g$peakName, "_", p2g$symbol)

    # Fake sample ID
    cand_bg$pair_id <- paste0(cand_bg$peakName, "_", cand_bg$gene)

    # remove true positive sample ID in Fake sample ID
    cand_neg <- cand_bg[!(cand_bg$pair_id %in% pos_id), ]
    
    ##----------------------------------
    ## 5. Box division by distance & distance matching sampling
    ##----------------------------------
    # Define box partitioning using all distances (break can also be manually set)
    breaks <- quantile(
      c(as.numeric(cand_neg$dist), as.numeric(p2g_use$dist_prom)),
      probs = seq(0, 1, by = 0.05),
      na.rm = TRUE)
    breaks <- unique(breaks) 
    
    # Add distance bin to both positive and candidate negative samples
    p2g_df <- as.data.frame(mcols(p2g_use))
    p2g_df$peakName <- p2g_use$peakName
    p2g_df$symbol   <- p2g_use$symbol
    p2g_df$dist_prom <- as.numeric(p2g_use$dist_prom)
    p2g_df$bin <- cut(p2g_df$dist_prom, breaks = breaks, include.lowest = TRUE)

    cand_df <- as.data.frame(cand_neg)
    cand_df$bin <- cut(as.numeric(cand_df$dist), breaks = breaks, include.lowest = TRUE)

    # Add Index
    cand_df$peak_idx <- cand_neg$peak_idx
    cand_df$prom_idx <- cand_neg$prom_idx
    
    p2g_df$chr <- as.character(seqnames(p2g_use))
    cand_df$chr <- as.character(seqnames(peak)[cand_df$peak_idx])

    n_neg_per_pos <- 3  

    neg_list <- lapply(seq_len(nrow(p2g_df)), function(i) {
      b   <- p2g_df$bin[i]
      chr <- p2g_df$chr[i]
      # Same distance bin + same chromosome
      pool <- cand_df[cand_df$bin == b & cand_df$chr == chr, ]
      if (nrow(pool) == 0L) return(NULL)

      pool[sample(nrow(pool),
                  size     = min(n_neg_per_pos, nrow(pool)),
                  replace  = n_neg_per_pos > nrow(pool)), ]
    })
    print(paste0( "The number of pseudo loops in each group is：", length(neg_list)))
    
    saveRDS(neg_list,"00.for_HiC.fake_pairs.3rep.rds")
    saveRDS(p2g_use,"00.for_HiC.true_pairs.cre_HBG.rds")
    
    
    ####### Merge contact files #########
    #####################################
    ## 1. set bin size
    bin_size <- 5000   

    ## 2. chr + bin location information（example："chr1_1234"）
    to_bin_bp <- function(chr, pos, bin_size) {
      start <- floor(pos / bin_size) * bin_size
      paste0(chr, ":", start)
    }


    ## 3. Read the contact file and aggregate by bin
    aggregate_one_file <- function(path, bin_size = 5000) {
      dt <- fread(path)  
      dt <- dt[V2 == V6]
      dt[, `:=`(
        chr1   = V2,
        start1 = ((V3 - 1L) %/% bin_size) * bin_size,
        chr2   = V6,
        start2 = ((V7 - 1L) %/% bin_size) * bin_size,
        w      = V8
      )]
    
      # Unified bin order to avoid duplication of (A, B) and (B, A)
      idx <- dt$start1 > dt$start2 | (dt$start1 == dt$start2 & dt$chr1 > dt$chr2)
      dt[idx, c("chr1","chr2","start1","start2") := .(chr2, chr1, start2, start1)]
  
      # merge by bin
      dt2 <- dt[, .(count = sum(w)), by = .(chr1, start1, chr2, start2)]
      dt2
    }

    ## 4. Aggregate all cell files above and merge them into a bulk
    files <- matched_df$path[which(matched_df$MajorType == hic_ct[i])]  

    all_pairs <- rbindlist(
      lapply(files, aggregate_one_file, bin_size = bin_size)
    )

    # Sum up the bin air contacts of all cells
    bulk_pairs <- all_pairs[
      , .(count = sum(count)),
      by = .(chr1, start1, chr2, start2)
    ]
    
    # bulk_pairs: data.table / data.frame，
    bp <- as.data.table(bulk_pairs)

    # Convert to integer coordinates
    bp[, start1 := as.integer(start1)]
    bp[, start2 := as.integer(start2)]

    # pos -> [pos-1, pos+1]
    bp[, `:=`(
      start1 = start1,  
      end1   = start1 + 5000L,
      start2 = start2,
      end2   = start2 + 5000L
    )]

    # output BEDPE（chr1 start1 end1 chr2 start2 end2 count）
    bedpe <- bp[, .(chr1, start1, end1, chr2, start2, end2, count)]

    # # Check if the first few lines meet expectations
    # head(bedpe)

    # output files
    # fwrite(bedpe, file = "02.all_bulk_pairs.bedpe", sep = "\t", col.names = FALSE)
    
    fwrite(bedpe, file = "01.all_bulk_pairs.bedpe", sep = "\t", col.names = FALSE)
       
          
    ########### Calculate interaction strength ############
    #######################################################
    pair <- readRDS("00.for_HiC.true_pairs.cre_HBG.rds")
    l5np = pair
    
    ##Assuming: 
    # # - pair's mcols have a column of symbols (gene names) 
    # # - promoters_gr's mcols also have a column of symbols (corresponding to the same set of gene names) 
    # # If you align with gene_id, change "symbol" to "gene_i"

    join_col <- "symbol"   # or "gene_id"

    # ---- 1) Convert pair (peak) to table：peak chr/start/end + metadata ----
    pair_dt <- as.data.table(mcols(l5np))
    pair_dt[, idx__ := seq_len(length(l5np))]

    pair_dt[, `:=`(
      peak_chr   = as.character(seqnames(l5np)),
      peak_start = start(l5np) - 1L,   # 0-based
      peak_end   = end(l5np)           # end-exclusive 
    )]

    # ---- 2) promoters_gr(promoter) Convert to table：promoter chr/start/end ----
    prom_dt <- as.data.table(mcols(promoters_gr))
    prom_dt[, `:=`(
      prom_chr   = as.character(seqnames(promoters_gr)),
      prom_start = start(promoters_gr) - 1L,  # 0-based
      prom_end   = end(promoters_gr)
    )]

    # (Optional) If the same gene appears multiple times in promoters_gr, first remove the duplicate and keep the first one
    # setkeyv(prom_dt, join_col)
    # prom_dt <- prom_dt[!duplicated(prom_dt[[join_col]])]

    # ---- 3) join by gene ----
    bedpe_dt <- merge(
      pair_dt,
      prom_dt[, c(join_col, "prom_chr", "prom_start", "prom_end"), with = FALSE],
      by = join_col,
      all.x = TRUE
    )

    #----4) Output BEDPE: peak three columns+promoter three columns (+fields you want to keep) ---- 
    # Basic 7 columns: chr1 start1 end1 chr2 start2 end2 name/score... 
    # Here, I keep join_coml and count/correction (if any)
    keep_extra <- intersect(c("peakName","symbol"), names(bedpe_dt))

    bedpe_out <- bedpe_dt[, c(
      "peak_chr", "peak_start", "peak_end",
      "prom_chr", "prom_start", "prom_end",
        keep_extra
    ), with = FALSE]

    # Check if there are any matches (theoretically not)
    if (any(is.na(bedpe_out$prom_chr))) {
      warning("Some rows in pair did not find promoter coordinates (prom_chr is NA).")
    }

    head(bedpe_out)

    # Write file (optional): Bedtools makes it easier to read (without writing the header)
    fwrite(bedpe_out, "pair_peak_promoter.bedpe", sep = "\t", col.names = FALSE)
    
    
    bedpe_out = bedpe_out[,c(1:6)]
    head(bedpe_out)
    fwrite(bedpe_out, "02.true_pair.bedpe", sep = "\t", col.names = FALSE,row.names=FALSE)      
          
    bedpe_out$peak_start = ((bedpe_out$peak_start - 1) %/% 5000) * 5000
    bedpe_out$peak_end = bedpe_out$peak_start + 5000
    bedpe_out$prom_start = ((bedpe_out$prom_start - 1) %/% 5000) * 5000
    bedpe_out$prom_end = bedpe_out$prom_start + 5000    
          
    colnames(bedpe_out) = c("chr1","start1","end1","chr2","start2","end2")
    # head(bedpe_out)
    
    dt = as.data.table(bedpe_out)

    # Unify bin order to avoid duplication of (A, B) and (B, A) (the same as bulk pairs)
    idx <- dt$start1 > dt$start2 | (dt$start1 == dt$start2 & dt$chr1 > dt$chr2)
      dt[idx, c("chr1","chr2","start1","start2") := .(chr2, chr1, start2, start1)]
    
    bulk_pairs = fread("/data/work/jinbufan/review/cCREs-HiC-L5NP/01.all_bulk_pairs.bedpe")
    colnames(bulk_pairs) = c("chr1","start1","end1","chr2","start2","end2","count")
    head(bulk_pairs)

    ## Calculate interaction strength
    loops_counts <- merge(
      dt,
      bulk_pairs,
      by = c("chr1","start1","chr2","start2"),
      all.x = TRUE
    )

    # Loop without contact, count set to 0
    loops_counts[is.na(count), count := 0L]
          
    
    ###########################################################

    #==== Calculate the interaction strength of fake pairs ====

    ###########################################################
    neg <- readRDS("00.for_HiC.fake_pairs.3rep.rds")
    
    ### ---------- 1) Split neg into 3 summary tables by row ----------
    # Take the r-th row (r=1/2/3) and put together all the elements of the list
    get_row_across_list <- function(lst, r) {
      rbindlist(lapply(lst, function(x) {
        x <- as.data.table(x)
        if (nrow(x) >= r) x[r, , drop = FALSE] else NULL
      }), fill = TRUE)
    }

    df_rep1 <- get_row_across_list(neg, 1)
    df_rep2 <- get_row_across_list(neg, 2)
    df_rep3 <- get_row_across_list(neg, 3)
    colnames(df_rep1)[4] = 'symbol'
    colnames(df_rep2)[4] = 'symbol'
    colnames(df_rep3)[4] = 'symbol'

    # Put it into a list for easy looping later
    rep_list <- list(rep1 = df_rep1, rep2 = df_rep2, rep3 = df_rep3)


    ### ---------- 2) Prepare a promoter table and join it using the gene name----------
    prom_gene_col <- "symbol"   # or"gene", or "gene_id"

    prom_dt <- data.table(
      symbol = mcols(promoters_gr)[[prom_gene_col]],
      prom_chr   = as.character(seqnames(promoters_gr)),
      prom_start = start(promoters_gr) - 1L,
      prom_end   = end(promoters_gr)
    )

    # deduplication
    setkey(prom_dt, symbol)
    prom_dt <- prom_dt[!duplicated(symbol)]


    ### ---------- 3) Convert each Rep data box to BEDPE ----------
    to_bedpe_peak_prom <- function(dt, prom_dt) {
      dt <- as.data.table(dt)

      # peakName: chr_start_end
      tmp <- tstrsplit(dt$peakName, "_", fixed = TRUE)
      dt[, `:=`(
        peak_chr   = tmp[[1]],
        peak_start = as.integer(tmp[[2]]),
        peak_end   = as.integer(tmp[[3]])
      )]

      # The peak coordinate is also converted to BED: start-1, and the end remains unchanged (consistent with the promoter above)
      dt[, peak_start := peak_start - 1L]

      # join promoter
      dt <- merge(dt, prom_dt, by.x = "symbol", by.y = "symbol", all.x = TRUE)

      # output Bedpe
      bedpe <- dt[, .(
        peak_chr, peak_start, peak_end,
        prom_chr, prom_start, prom_end
      )]
    
      bedpe
    }

    bedpe_rep1 <- to_bedpe_peak_prom(rep_list$rep1, prom_dt)
    bedpe_rep2 <- to_bedpe_peak_prom(rep_list$rep2, prom_dt)
    bedpe_rep3 <- to_bedpe_peak_prom(rep_list$rep3, prom_dt)
    
    bedpe_rep1[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L, 
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L   
    )]
    print("first run")
    head(bedpe_rep1)
    
    bedpe_rep1[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L,  
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L   
    )]
    print("second run")
    head(bedpe_rep1)
    
    ## first 
    bedpe_rep2[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L,
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L
    )]
    bedpe_rep3[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L,
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L
    )]
    ## second
     bedpe_rep2[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L,
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L
    )]
    bedpe_rep3[, `:=`(
      peak_start = ((peak_start) %/% 5000L) * 5000L,
      peak_end   = peak_start + 5000L,
      prom_start = ((prom_start) %/% 5000L) * 5000L,
      prom_end   = prom_start + 5000L
    )]
    
    colnames(bedpe_rep1) = c("chr1","start1","end1","chr2","start2","end2")
    colnames(bedpe_rep2) = c("chr1","start1","end1","chr2","start2","end2")
    colnames(bedpe_rep3) = c("chr1","start1","end1","chr2","start2","end2")

    # Unify bin order to avoid duplication of (A, B) and (B, A) (the same as bulk pairs)
    idx <- bedpe_rep1$start1 > bedpe_rep1$start2 | (bedpe_rep1$start1 == bedpe_rep1$start2 & bedpe_rep1$chr1 > bedpe_rep1$chr2)
      bedpe_rep1[idx, c("chr1","chr2","start1","start2") := .(chr2, chr1, start2, start1)]

    idx <- bedpe_rep2$start1 > bedpe_rep2$start2 | (bedpe_rep2$start1 == bedpe_rep2$start2 & bedpe_rep2$chr1 > bedpe_rep2$chr2)
      bedpe_rep2[idx, c("chr1","chr2","start1","start2") := .(chr2, chr1, start2, start1)]

    idx <- bedpe_rep3$start1 > bedpe_rep3$start2 | (bedpe_rep3$start1 == bedpe_rep3$start2 & bedpe_rep3$chr1 > bedpe_rep3$chr2)
      bedpe_rep3[idx, c("chr1","chr2","start1","start2") := .(chr2, chr1, start2, start1)]

    ## Calculate interaction strength
    loops_fake1 <- merge(bedpe_rep1,bulk_pairs,by = c("chr1","start1","chr2","start2"),all.x = TRUE)
    # 没有 contact 的 loop，count 设为 0
    loops_fake1[is.na(count), count := 0L]

    loops_fake2 <- merge(bedpe_rep2,bulk_pairs,by = c("chr1","start1","chr2","start2"),all.x = TRUE)
    loops_fake2[is.na(count), count := 0L]

    loops_fake3 <- merge(bedpe_rep3,bulk_pairs,by = c("chr1","start1","chr2","start2"),all.x = TRUE)
    loops_fake3[is.na(count), count := 0L]  
        
    ########### plot #########
    all_counts <- rbindlist(list(loops_counts, loops_fake1, loops_fake2, loops_fake3), idcol = "group")
    all_counts$group <- factor(all_counts$group, levels = c("1","2","3","4"))
    
    pdf("result.pdf" , 6, 8)
        p = ggplot(all_counts, aes(x = group, y = count, fill = group)) +
          geom_boxplot() +
          theme_minimal() +
          labs(title = paste0("Comparison of loop interaction counts：", atac_ct[i]),
               x = "Group",
               y = "Interaction Count") +
          theme(axis.text.x = element_text(angle = 45, hjust = 1))
        print(p)
    dev.off()
    print(p)
    
    kruskal.test(count ~ group, data = all_counts)
    wilcox.test(count ~ group, data = all_counts[all_counts$group %in% c("1", "4")])
    saveRDS(all_counts,paste0(atac_ct[i] , "_result.rds"))
}

