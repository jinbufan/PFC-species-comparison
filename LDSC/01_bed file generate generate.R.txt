#!/usr/bin/env Rscript

##########################################################################
# 01 Generate an region bed files to make annot files for LD score regression
##########################################################################

# See here: https://github.com/bulik/ldsc/wiki/LD-Score-Estimation-Tutorial
# Annot file will be made from peaks identified in scATAC data
# Annot file has the following columns:
# CHR, BP, SNP, and CM (centimorgan), followed by one column per annotation
# The value of the annotation for each SNP can be 0/1 for binary categories, 
# or arbitrary numbers for continuous annotations.
# The file can have many categories, or just a single category


#Load ArchR (and associated libraries)
suppressPackageStartupMessages({
  library(ArchR)
  library(dplyr)
  library(tidyr)
  library(rtracklayer)
})

# Get additional functions, etc.:
scriptPath <- "/data/work/Human/01.ATAC-analysis/00.script"
source(paste0(scriptPath, "/Greenleaf-nature genetic-Support-Function.R"))

message("Generating cell type-specific peak sets...")

# Set Threads to be used
addArchRThreads(threads = 16)

ident <- "FineClust"
archrDir <- '/data/users/jinbufan/online/01.human_brain/Final_output/Save-ArchR-Project.rds'
outdir <- "/data/work/Human/03.LDSC/01_bed_files/"
minPeaks <- 2000   
minCells <- 50
resizePeakWidth <- 500
liftToHg19 <- TRUE # Should peak coordinates be lifted over to hg19?

# set output directory
# outdir <- paste0(outdir, sprintf("/%s_specific_peaks", ident))

#Set/Create Working Directory to Folder
# dir.create(outdir, showWarnings = FALSE, recursive = TRUE)

# Load ArchR project
proj <- readRDS(archrDir)

# Modify Path
proj@projectMetadata$outputDirectory<-"/data/users/jinbufan/online/01.human_brain/Final_output"
proj@cellColData$outputDirectory<-"/data/users/jinbufan/online/01.human_brain/Final_output"
table(proj@cellColData$Clusters)
arrowfile <- "/data/users/jinbufan/online/01.human_brain/Final_output/ArrowFiles"
for(i in 1:length(proj@sampleColData$ArrowFiles)){
  proj@sampleColData$ArrowFiles[i] <- paste(arrowfile,basename(proj@sampleColData$ArrowFiles[i]),sep="/")
}

# Load full peakset
peaksGR <- getPeakSet(proj)
names(peaksGR) <- (peaksGR %>% {paste(seqnames(.), start(.), end(.), sep="_")})

peak = readRDS("/data/users/jinbufan/online/01.human_brain/02.file/peak_result_0628/00.02.human_peakSet_level.detailed.240729.rds")
peak$peakName = factor(peak$peakName)
peak$level = peak$state
peak[peak$state %in% c("mammal_conserved_level0","mammal_conserved_level1","mammal_conserved_level2","mammal_conserved_level2.2") , ]$level = "mammal_conserved"
table(peak$state)  ## hg38
table(peak$level)  ## hg38
chain <- import.chain("/data/work/Human/database/hg38ToHg19.over.chain")
peak = liftOver(peak, chain) %>% unlist()
table(peak$level)  ## hg19

#########################################################
# Peak selection using all peaks filtered for overlap
#########################################################

ccd <- proj@cellColData
clust_freqs <- getFreqs(ccd[,ident])
use_clust <- names(clust_freqs)[clust_freqs > minCells]

# Set the max number of overlapping clusters per peak to be 1/4 the total number of clusters
# cutoff <- floor(length(use_clust)/4)
cutoff <- 4

cts_peaks <- lapply(use_clust, function(x) getClusterPeaks(proj, clusterNames=x, peakGR=peaksGR))
names(cts_peaks) <- use_clust

# Construct matrix of peak usage by cluster
peak_mat <- matrix(0, nrow=length(peaksGR), ncol=length(use_clust))
rownames(peak_mat) <- names(peaksGR)
colnames(peak_mat) <- use_clust

# Fill in matrix
for(clust in use_clust){
  peak_mat[names(cts_peaks[[clust]]), clust] <- 1
}

# Determine overlap for each peak
peak_usage <- Matrix::rowSums(peak_mat)
names(peak_usage) <- rownames(peak_mat)

# Plot peak-sharing information
nclust_per_peak <- getFreqs(peak_usage)
df <- data.frame(nClust=as.integer(names(nclust_per_peak)), nPeaks=nclust_per_peak)
df <- df[order(df$nClust),]

pdf(paste0(outdir, "/nClusters_per_peak.pdf"), width=8, height=6)
qcBarPlot(df, cmap="royalblue1", barwidth=0.9, border_color=NA) + geom_vline(xintercept=cutoff + 0.5, linetype="dashed")
dev.off()

# Percent of total peaks
df <- rbind(c(0,0), df)
df$cumulative <- cumsum(df$nPeaks)
df$cumulative <- df$cumulative / max(df$cumulative)
pct_peaks_passing <- df[df$nClust == cutoff,]$cumulative %>% round(.,2)

pcol <- "royalblue1"
p <- (
  ggplot(df, aes(x=df[,1], y=df[,3]))
  + geom_line(size=2, color=pcol)
  + scale_fill_manual(values = pcol)
  + xlab(colnames(df)[1])
  + ylab(colnames(df)[3])
  + theme_BOR(border=FALSE)
  + theme(panel.grid.major=element_blank(), 
          panel.grid.minor= element_blank(), 
          plot.margin = unit(c(0.25,1,0.25,1), "cm"), 
          axis.text.x = element_text(angle = 90, hjust = 1))
  + scale_y_continuous(expand = c(0, 0)) # Make bars start at the axis
  )
p <- p + geom_vline(xintercept=cutoff, linetype="dashed") + geom_hline(yintercept=pct_peaks_passing, linetype="dashed")
p <- p + annotate("text",  x=-Inf, y = Inf, label = paste0(pct_peaks_passing*100, "%"), vjust=1, hjust=-1)

pdf(paste0(outdir, "/cumulative_pct_peaks.pdf"), width=8, height=6)
p
dev.off()

# Identify which peaks to use for each cluster
filt_peak_mat <- peak_mat[peak_usage <= cutoff,]

markerGRList <- lapply(use_clust, function(clust){
  clust_vec <- filt_peak_mat[,clust]
  peaksGR[names(clust_vec[clust_vec>0])]
  })
names(markerGRList) <- use_clust

# Filter clusters that had too few peaks:
markerGRList <- markerGRList[lapply(markerGRList, length) > minPeaks]

# Add a GR of all peaks to use as background
# markerGRList[["allPeaks"]] <- getPeakSet(proj)

############################### Peak sorting by cell type #########################
############################### Peak sorting by cell type #########################                  
                    
if(liftToHg19){
  message("Lifting over peak coordinates from hg38 to hg19...")
  chain <- import.chain("/data/work/Human/database/hg38ToHg19.over.chain")  
  nms <- names(markerGRList)
  markerGRList <- lapply(names(markerGRList), function(x){
    liftOver(markerGRList[[x]], chain) %>% unlist()
    })
  names(markerGRList) <- nms
}

# Save coordinate bed files to use for generating annot files

for(ctype in names(markerGRList)){
    gr <- markerGRList[[ctype]] %>% sort() %>% resize(., width=resizePeakWidth, fix="center")
    gr$peakName = names(gr)
    gr$peakName = factor(gr$peakName)
    gr$state = ""
    gr$state = peak$level[match(gr$peakName,peak$peakName)]
    table(gr$state)
    for(levels in c("human_specific_peak","human_specific_sequence","mammal_conserved")){
      gr_l = gr[gr$state == levels , ]
      df <- DataFrame(
        chrom=seqnames(gr_l),
        start=start(gr_l)-1,
        end=end(gr_l))
      print(paste0( ctype, ":  " , df@nrows))
      write.table(df, paste0("/data/work/Human/03.LDSC/01_bed_files/",levels,"/",ctype,".bed") , quote=FALSE, sep='\t', row.names = FALSE, col.names = FALSE)
    }
}
message("Done")

## view peaks
table(names(markerGRList))